* Docs
** Breaking down a transaction
*** P2PK/P2PKH
Below example uses block 71000 that has just one simple transaction (and a coinbase)

raw transaction:
0100000001fb4209d1cea10533e43658cfb97d951b8336540ff23e13ed1f885d8eb29fee70000000008b483045022043804fdeb4fb1b0f9ef0172a24445695a10a303f228f9a2a36d3347f0f5fed7c022100d8b09cfa712d1936df08318c20a6745ec54974464299a1c886e4782055ebd6c9014104e9456d14351e5bd0ee65158ad30068ee2411cdd307142dfbf11ed905df8284a1cd82e977fbb294895d9fdfa1c8bc37d619d3dc422420ad63110ac3ea74fe74a7ffffffff01005ed0b2000000001976a914da29060ed73fb201083cc748c7b58d7a290ea7ad88ac00000000

broken out:
version (4-byte, little-endian): 01000000
input count (compact size): 01

input 1:
txid: fb4209d1cea10533e43658cfb97d951b8336540ff23e13ed1f885d8eb29fee70
vout (little-endian): 00000000
scriptSig size (compact size): 8b
scriptSig: 483045022043804fdeb4fb1b0f9ef0172a24445695a10a303f228f9a2a36d3347f0f5fed7c022100d8b09cfa712d1936df08318c20a6745ec54974464299a1c886e4782055ebd6c9014104e9456d14351e5bd0ee65158ad30068ee2411cdd307142dfbf11ed905df8284a1cd82e977fbb294895d9fdfa1c8bc37d619d3dc422420ad63110ac3ea74fe74a7
sequence (little endian): ffffffff

output count: 01

ouptut 1:
amount (little-endian): 005ed0b200000000
scriptPubKey size (compact-size): 19
scriptPubKey: 76a914da29060ed73fb201083cc748c7b58d7a290ea7ad88ac

locktime (4-byte, little-endian): 00000000

*** P2TR
This is from the first P2TR utxo. nice.

raw transaction:
01000000000101d1f1c1f8cdf6759167b90f52c9ad358a369f95284e841d7a2536cef31c0549580100000000fdffffff020000000000000000316a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e204062697462756734329e06010000000000225120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f90140a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174affd30a00

broken out:
version (4-byte, little-endian): 01000000
marker (byte): 00 # MUST be 0x00 indicates SegWit
flag (byte): 01   # 1 or greater indicates SegWit

input count (compact size): 01

input 1:
txid (32-byte, native byte order): d1f1c1f8cdf6759167b90f52c9ad358a369f95284e841d7a2536cef31c054958
vout (4-byte, little-endian): 01000000
scriptSig size (compact size): 00  # SegWit
scriptSig (variable): empty
sequence (4-byte, little-endian): fdffffff

output count  (compact size): 02

output 1:
amount (8-byte, little-endian): 0000000000000000
scriptPubKey size (compact size): 0x31 (49-bytes)
scriptPubKey (variable): 6a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e20406269746275673432

output 2:
amount (8-byte, little-endian): 9e06010000000000
scriptPubKey size (compact size): 0x22 (34-bytes)
scriptPubKey: 5120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f9

the Witness

stack items (compact size): 01
size (compact size): 0x40 (64-bytes):
a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174a

locktime (4-byte, little-endian): ffd30a00

"txid": "33e794d097969002ee05d336686fc03c9e15a597c1b9827669460fac98799036",
  "hash": "af2fdc4c54270adfb2a65987a79ed2f0e771a779ea48bb0ef06095b48395f74d",
  "version": 1,
  "size": 220,
  "vsize": 169,
  "weight": 676,
  "locktime": 709631,
  "vin": [
    {
      "txid": "5849051cf3ce36257a1d844e28959f368a35adc9520fb9679175f6cdf8c1f1d1",
      "vout": 1,
      "scriptSig": {
        "asm": "",
        "hex": ""
      },
      "txinwitness": [
        "a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174a"
      ],
      "prevout": {
        "generated": false,
        "height": 709632,
        "value": 0.00088480,
        "scriptPubKey": {
          "asm": "1 339ce7e165e67d93adb3fef88a6d4beed33f01fa876f05a225242b82a631abc0",
          "desc": "rawtr(339ce7e165e67d93adb3fef88a6d4beed33f01fa876f05a225242b82a631abc0)#qdul2rkc",
          "hex": "5120339ce7e165e67d93adb3fef88a6d4beed33f01fa876f05a225242b82a631abc0",
          "address": "bc1pxwww0ct9ue7e8tdnlmug5m2tamfn7q06sahstg39ys4c9f3340qqxrdu9k",
          "type": "witness_v1_taproot"
        }
      },
      "sequence": 4294967293
    }
  ],
  "vout": [
    {
      "value": 0.00000000,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_RETURN 49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e20406269746275673432",
        "desc": "raw(6a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e20406269746275673432)#nqj73zc7",
        "hex": "6a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e20406269746275673432",
        "type": "nulldata"
      }
    },
    {
      "value": 0.00067230,
      "n": 1,
      "scriptPubKey": {
        "asm": "1 a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f9",
        "desc": "rawtr(a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f9)#er2wu6lc",
        "hex": "5120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f9",
        "address": "bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297",
        "type": "witness_v1_taproot"
      }
    }
  ],
  "fee": 0.00021250,
  "hex": "01000000000101d1f1c1f8cdf6759167b90f52c9ad358a369f95284e841d7a2536cef31c0549580100000000fdffffff020000000000000000316a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e204062697462756734329e06010000000000225120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f90140a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174affd30a00",
  "blockhash": "00000000000000000001f9ee4f69cbc75ce61db5178175c2ad021fe1df5bad8f",
  "confirmations": 197299,
  "time": 1636868413,
  "blocktime": 1636868413
}
* Imports
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

from typing import List

# import sys
# sys.path.append('..')
from helpers import bytes_to_hex, get_compact_size, hex_to_bytes, reverse_bytes
from hashes import hash256

#+end_src

* TxIn Class
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class TxIn:
    '''Input class for Bitcoin transactions'''
    def __init__(self, txid: str=None, vout: int=None, scriptSig: str=None, sequence: int=0xffffffff):
        '''Initialize the Input'''

        # Transaction ID of the prev output we want to spend
        if not txid:
            raise ValueError("You must provide a hex string txid for each input")
        if not (isinstance(int(txid, 16), int) and len(txid) == 64):
            raise ValueError("txid must be a 32-byte hex string for each input")
        self.txid = txid

        # Vout we want to spend
        if not isinstance(vout, int):
            raise ValueError("You must provide an integer vout for each input")
        if vout.bit_length() // 8 > 4:
            raise ValueError("vout must be no larger than 4 bytes for each input")
        self.vout = vout

        # ScriptSig for prev output
        if not scriptSig:
            raise ValueError("You must provide a hex string scriptSig for each input")
        # if not int(scriptSig, 16):
        #     raise ValueError("scriptSig must be a hex string")
        self.scriptSig_size = get_compact_size(len(scriptSig) // 2)  # size of the scriptSig in bytes
        self.scriptSig = scriptSig  # signature

        # Sequence for e.g. replace-by-fee
        if not (0x0 <= sequence and sequence <= 0xffffffff):
            raise ValueError("Sequence must be an integer between 0 and 0xffffffff")
        self.sequence = sequence

    def serialize(self) -> bytes:
        '''return the serialize data for this input'''
        b = hex_to_bytes(self.txid)[::-1]
        b += self.vout.to_bytes(4, 'little')
        b += hex_to_bytes(self.scriptSig_size)
        b += hex_to_bytes(self.scriptSig)
        b += self.sequence.to_bytes(4, 'little')
        return b

#+end_src

* SegwitTxIn
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class SegwitTxIn(TxIn):
    '''Segregated Witness (SegWit) transaction class, moves scriptSig to witness area'''

    def __init__(self, txid: str=None, vout: int=None, witness: List[int]=None, sequence: int=0xffffffff):
        '''Initialize the transaction'''
        super().__init__(txid=txid, vout=vout, scriptSig='00', sequence=sequence)

        self.segwit = True

        if not witness:
            raise ValueError("a witness is required for every SegWit input")
        self.witness = witness
        self.stack_size = get_compact_size(len(witness))

    def serialize(self):
        '''return the serialized blob for a segwit input'''
        b = hex_to_bytes(self.txid)[::-1]
        b += self.vout.to_bytes(4, 'little')
        b += b'\x00'  # no scriptSig
        b += self.sequence.to_bytes(4, 'little')
        return b

#+end_src

* TxOut Class
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class TxOut:
    '''Output class for Bitcoin transactions'''
    def __init__(self, amount: int=None, scriptPubKey: str=None):
        # if not amount:
        #     raise ValueError("amount must be an integer num of satoshis you wish to spend")
        if not (0 <= amount and amount < 2100000000000000):
            raise ValueError("invalid amount, 0 < amount < 2100000000000000")
        self.amount = amount  # satoshis going to this output as an int

        # scriptPubKey for output
        if not scriptPubKey:
            raise ValueError("You must provide a scriptPubKey for every output")
        self.scriptPubKey_size = get_compact_size(len(scriptPubKey) // 2)
        self.scriptPubKey = scriptPubKey

    def serialize(self) -> bytes:
        '''return the serialized data for this output'''
        b = self.amount.to_bytes(8, 'little')
        b += hex_to_bytes(self.scriptPubKey_size)
        b += hex_to_bytes(self.scriptPubKey)
        return b

#+end_src

* Transaction Class
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class Transaction:
    '''Base class for (Legacy) Bitcoin P2PK/P2PKH transactions'''

    def __init__(self, inputs: List[TxIn]=None, outputs: List[TxOut]=None, locktime: int=0):
        '''Initialize transaction'''

        self.version = 0x01.to_bytes(4, 'little')

        # TX Inputs
        if not inputs:
            raise ValueError("You must provide a list of valid Tx Inputs that you wish to spend.")
        self.input_cnt = get_compact_size(len(inputs))
        self.inputs = inputs

        # TX Outputs
        if not outputs:
            raise ValueError("You must provide a list of valid Tx Outputs that you wish to send to.")
        self.outputs = outputs
        self.output_cnt = get_compact_size(len(outputs))

        if not (0 <= locktime and locktime <= 0xffffffff):
            raise ValueError("locktime must be an integer s.t. 0 <= locktime <= 0xffffffff")
        self.locktime = locktime

    def get_txid(self) -> int:
        '''Generate the transaction ID'''
        return reverse_bytes(bytes_to_hex(hash256(hex_to_bytes(self.serialize()))))

    def get_txhash(self) -> int:
        '''return transaction hash, this is identical to the txid for pre-segwit transactions'''
        return self.get_txid()

    def serialize(self) -> bytes:
        '''Serialize the transaction'''
        # version
        b = self.version

        # inputs
        b += hex_to_bytes(self.input_cnt)
        for i in self.inputs:
            b += i.serialize()

        # outputs
        b += hex_to_bytes(self.output_cnt)
        for o in self.outputs:
            b += o.serialize()

        # locktime
        b += self.locktime.to_bytes(4, 'little')
        return bytes_to_hex(b)

#+end_src

* SegwitTransaction
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class SegwitTransaction(Transaction):
    '''SegwitTransaction Class'''

    def __init__(self, version: int=0x02, vin: List[TxIn]=None, vout: List[TxOut]=None, locktime: int=0):
        '''Initialize SegWit Transaction'''
        super().__init__(inputs=vin, outputs=vout, locktime=locktime)

        # version
        if not (0 < version and version < 3):
            raise ValueError("version in {0x1 (legacy), 0x2 (SegWit)}")
        self.version = version

        # marker/flag
        self.marker = b'\x00' # must be 0x00
        self.flag = b'\x01'  # must be flag > 0x01. may change w/ future protocol versions.

    def get_txid(self) -> bytes:
        '''return the txid of the transaction (markerflag + witness excluded)'''
        b = self.version.to_bytes(4, 'little')
        b += hex_to_bytes(self.input_cnt)

        # TODO mixed case, some segwit and some non-segwit inputs
        for i in self.inputs:
            b += i.serialize()

        b += hex_to_bytes(self.output_cnt)
        for o in self.outputs:
            b += o.serialize()

        b += self.locktime.to_bytes(4, 'little')

        return reverse_bytes(bytes_to_hex(hash256(b)))

    def get_txhash(self) -> int:
        '''return the hash of the whole blob (witness + markerflag included)'''
        return reverse_bytes(bytes_to_hex(hash256(hex_to_bytes(self.serialize()))))

    def serialize(self) -> bytes:
        '''return the transaction in raw form'''
        # version
        b = self.version.to_bytes(4, 'little')

        # marker/flag
        b += self.marker
        b += self.flag

        # inputs
        b += hex_to_bytes(self.input_cnt)
        for i in self.inputs:
            b += i.serialize()

        # outputs
        b += hex_to_bytes(self.output_cnt)
        for o in self.outputs:
            b += o.serialize()

        # the Witness repeated...
        # (stack items, stack=[(item_0 size, item_0), (item_1_size, item_1), ...])
        for i in self.inputs:
            if i.segwit:
                b += hex_to_bytes(i.stack_size)  # add stack size
                for _ in i.witness:
                    b += hex_to_bytes(get_compact_size(len(_) // 2))
                    b += hex_to_bytes(_)  # add each stack item

        # locktime
        b += self.locktime.to_bytes(4, 'little')

        return bytes_to_hex(b)

#+end_src

* TaprootTransaction Class
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

class TaprootTransaction(SegwitTransaction):
    '''TaprootTransaction class'''

    def __init__(self, version: int=0x02, vin: List[TxIn]=None, vout: List[TxOut]=None, MAST: List[int]=None, locktime: int=0):
        '''Initialize Segwit v1, TaprootTransaction'''
        super().__init__(version=version, vin=vin, vout=vout, locktime=locktime)
        if MAST:
            pass

#+end_src

* Test Cases
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

# Satoshi --> Hal (P2PK)
HAL_BLOCK_N = 170

# 10,000 btc pizza
PIZZA_BLOCK_N =  57043



#
# # Test Cases
#
# TEST = {'Vin': [{ "txid": "int" / hex str,
#                   "vout": int,
#                   "scriptSig": "int" / hex str,
#                   "sequence": int
#                   "segwit": bool
#                   "witness": (req. for segwit) "int" / hex str }],
#         'Vout': [{"amount": int (# of sats),
#                   "scriptPubkey": "int" / hex str }],
#         'TXID': int / hex str,
#         'HASH': int / hex str,,
#         'HEX': int / hex str,,
#         ’nLocktime’: (optional) int }



# Test: Satoshi --> Hal

SAT_HAL = { 'desc': "The first Bitcoin transaction between Satoshi and Hal Finney",
           'version': 1,
           'Vin':[{ "txid": "0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9",
                    "vout": 0,
                    "scriptSig": "47304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901",
                    "sequence": 4294967295,
                    "segwit": False }],
           'Vout': [{"amount": 1000000000,
                     "scriptPubkey": "4104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac"},
                    {"amount": 4000000000,
                     "scriptPubkey": "410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac"}],
           'TXID': "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16",
           'HASH': "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16",
           'HEX': "0100000001c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704000000004847304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901ffffffff0200ca9a3b00000000434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac00286bee0000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac00000000" }



# Test: Early P2SH

P2SH_TEST = {'desc': "An early P2SH Transaction",
             'version': 1,
             'Vin': [{ "txid": "42a3fdd7d7baea12221f259f38549930b47cec288b55e4a8facc3c899f4775da",
                       "vout": 0,
                       "scriptSig": "473044022048d1468895910edafe53d4ec4209192cc3a8f0f21e7b9811f83b5e419bfb57e002203fef249b56682dbbb1528d4338969abb14583858488a3a766f609185efe68bca0121031a455dab5e1f614e574a2f4f12f22990717e93899695fb0d81e4ac2dcfd25d00",
                       "sequence": 4294967295,
                       "segwit": False}],
             'Vout': [{"amount": 990000,
                       "scriptPubkey": "a914e9c3dd0c07aac76179ebc76a6c78d4d67c6c160a87" }],
             'TXID': "40eee3ae1760e3a8532263678cdf64569e6ad06abc133af64f735e52562bccc8",
             'HASH': "40eee3ae1760e3a8532263678cdf64569e6ad06abc133af64f735e52562bccc8",
             'HEX': "0100000001da75479f893cccfaa8e4558b28ec7cb4309954389f251f2212eabad7d7fda342000000006a473044022048d1468895910edafe53d4ec4209192cc3a8f0f21e7b9811f83b5e419bfb57e002203fef249b56682dbbb1528d4338969abb14583858488a3a766f609185efe68bca0121031a455dab5e1f614e574a2f4f12f22990717e93899695fb0d81e4ac2dcfd25d00ffffffff01301b0f000000000017a914e9c3dd0c07aac76179ebc76a6c78d4d67c6c160a8700000000" }



# Test: Segwit v0

Segwit_v0_Test = {'desc': "An early Segwit v0 transaction",
                  'version': 2,
                  'Vin': [{ "txid": "8c655da543f574b6af8b1cdeb15cf3cdee89395e43c574264521e81f6ede533a",
                            "vout": 54,
                            "witness": ["304402201250febbce0a5b333c2d715b869cb960f5abf1702192c7af6e112c6d6030be880220073c55f4814a064bf804d9ed16b57eaaeaafb536c4187e6260ef3fc61ca98a7701",
        "02e71911951e1f9799d5ccd05200ea0c18f786cb1bb45754d4a0799a06c2b80e80"],
                            'sequence': 4294967293,
                            'segwit': True }],
                  'Vout': [{"amount": 82483801,
                            "scriptPubkey": "0014cfbd92a6337e8b6043552d6fc5c35c7e5062281e" }],
                  'TXID': "6cd9ff242a04dbb6b0683c2b8576c397f341b7f0c1747b206f878db597a4cd01",
                  'HASH': "2fda6b0f657b21d78d9979ec84476a7cd8204fbf2e4e09d704144f74f67557e1",
                  'HEX': "020000000001013a53de6e1fe821452674c5435e3989eecdf35cb1de1c8bafb674f543a55d658c3600000000fdffffff01599aea0400000000160014cfbd92a6337e8b6043552d6fc5c35c7e5062281e0247304402201250febbce0a5b333c2d715b869cb960f5abf1702192c7af6e112c6d6030be880220073c55f4814a064bf804d9ed16b57eaaeaafb536c4187e6260ef3fc61ca98a77012102e71911951e1f9799d5ccd05200ea0c18f786cb1bb45754d4a0799a06c2b80e8000000000" }



# Test: Taproot

First_P2TR_test = { 'desc': "the first P2TR tx",
                    'version': 1,
                    'Vin': [{ "txid": "5849051cf3ce36257a1d844e28959f368a35adc9520fb9679175f6cdf8c1f1d1",
                              "vout": 1,
                              "witness": ["a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174a"],
                             'segwit': True,
                             'sequence': 4294967293 }],
                    'Vout': [{ "amount": 0,
                               "scriptPubkey": "6a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e20406269746275673432" },
                             { "amount": 67230,
                               "scriptPubkey": "5120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f9" }],
                    'TXID': "33e794d097969002ee05d336686fc03c9e15a597c1b9827669460fac98799036",
                    'HASH': "af2fdc4c54270adfb2a65987a79ed2f0e771a779ea48bb0ef06095b48395f74d",
                    'HEX': "01000000000101d1f1c1f8cdf6759167b90f52c9ad358a369f95284e841d7a2536cef31c0549580100000000fdffffff020000000000000000316a2f49206c696b65205363686e6f7272207369677320616e6420492063616e6e6f74206c69652e204062697462756734329e06010000000000225120a37c3903c8d0db6512e2b40b0dffa05e5a3ab73603ce8c9c4b7771e5412328f90140a60c383f71bac0ec919b1d7dbc3eb72dd56e7aa99583615564f9f99b8ae4e837b758773a5b2e4c51348854c8389f008e05029db7f464a5ff2e01d5e6e626174affd30a00",
                    'nLocktime': 709631 }

#+end_src

* Test Functions
#+begin_src python :tangle ../transaction.py :results silent :session pybtc

def run_test(test: dict):
    '''Run a single test'''

    isSegwit = False

    inputs = []
    for i in test['Vin']:
        if i['segwit']:
            inputs.append(
                SegwitTxIn(txid=i['txid'], vout=i['vout'], witness=i['witness'], sequence=i['sequence']))
            isSegwit = True
        else:
            inputs.append(
                TxIn(txid=i['txid'], vout=i['vout'], scriptSig=i['scriptSig'], sequence=i['sequence']))

    outputs = []
    for o in test['Vout']:
        outputs.append(
            TxOut(amount=o['amount'], scriptPubKey=o['scriptPubkey']))

    locktime = test['nLocktime'] if 'nLocktime' in test else 0

    if isSegwit:
        tx = SegwitTransaction(version=test['version'], vin=inputs, vout=outputs, locktime=locktime)
    else:
        tx = Transaction(inputs=inputs, outputs=outputs, locktime=locktime)

    assert tx.get_txid() == test['TXID'], f"\nTest Failed: {test['desc']}\nExpected: {test['TXID']}\nGot:\t{tx.get_txid()}"
    assert tx.serialize() == test['HEX'], f"\nTest Failed: {test['desc']}\nExpected:{test['HEX']}\nGot:\t {tx.serialize()}"
    assert tx.get_txhash() == test['HASH'], f"\nTest Failed: {test['desc']}\nExpected:{test['HASH']}\nGot:\t {tx.get_txhash()}"

    print(f"\nTest Passed: {test['desc']}\n")
    print(f"TXID: {tx.get_txid()}")
    print(f"TXHASH: {tx.get_txhash()}")
    print(f"HEX: {tx.serialize()}")


def run_tests():
    run_test(SAT_HAL)
    run_test(P2SH_TEST)
    run_test(Segwit_v0_Test)
    run_test(First_P2TR_test)

#+end_src

* Main
#+begin_src python :tangle ../transaction.py :results silent :session

if __name__ == '__main__':
    run_tests()

#+end_src
