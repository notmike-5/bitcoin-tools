* Import
#+begin_src python :tangle yes :results silent :session pybtc
import json
import os
import requests

#+end_src

* Function
#+begin_src python :tangle yes :results silent :session pybtc
def _get_cookie(cookiefile: str) -> (str, str):
    '''Obtain the cookie for cookie auth (default)'''
    if not os.path.exists(cookiefile):
        raise FileNotFoundError(
            f"Cookie not found at {cookiefile}. Ensure bitcoind is running and datadir is correct.")
    with open(cookiefile, 'r', encoding='utf-8') as f:
        cookie = f.read().strip()
        if ':' not in cookie:
            raise ValueError(f"Invalid cookiefile format user:hashpass in {cookiefile}.")
    cookie_user, cookie_pass = cookie.split(':', 1)

    return (cookie_user, cookie_pass)

def make_rpc_call(method: str = "getblockchaininfo",
                  params: list = None,
                  user: str = None,
                  password: str = None,
                  datadir: str ="~/.bitcoin",
                  rpc_url: str = "http://127.0.0.1:8332"):
    '''Handle rpc calls to the bitcoind'''
    headers = {'content-type': 'application/json'}
    payload = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method,
        "params": params or []
    }

    if user is not None and password is not None:
        auth = (user, password)
    else:
        if datadir == '~/.bitcoin':
            datadir = os.path.expanduser(datadir)
        cookie_file = os.path.join(datadir, '.cookie')
        auth = _get_cookie(cookie_file)

    try:
        response = requests.post(
            rpc_url,
            auth=auth,
            data=json.dumps(payload),
            headers=headers,
            timeout = 1.5
        )
        response.raise_for_status()  # Raise error on bad HTTP status
        return response.json().get('result')
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        return None

#+end_src
