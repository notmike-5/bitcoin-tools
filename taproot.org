* Docs
Taproot Transaction

!!!make sure tweaked public key has an even y-coordinate (per BIP-340)!!!!

- txid
- hash
- version: \x00\x00\x00\x02 (for SegWit)
- size
- vsize
- weight
- locktime (0 for immediate spend)

Input:
 - txid 32-byte little-endian
 - vout 4-byte
 - scriptSig e.g. {"asm": _,
                   "hex": _ } (for SegWit)
 - txinwitness []
 - sequence typ. 0xffffffff

- vin: [input_0, input_1, ..., input_n]

- vout: [output_0, output_1, ..., output_n]
 - value
 - n
 - scriptPubkey eg {"asm": _,
                    "desc": _,
                    "hex": _,
                    "address": _,
                    "types": _ }

# Spending
Step 5: Sign the Transaction (Key-Path Spend)

    Compute the Sighash:
        Use BIP-341 sighash rules for Taproot.
        Sighash type: Typically SIGHASH_DEFAULT (0x00, covers all inputs/outputs).
        Serialize transaction data (version, inputs, outputs, etc.) per BIP-341.
        Hash with SHA256 to get the sighash.
    Sign with Schnorr:
        Use the private key corresponding to the internal public key.
        Generate a Schnorr signature (64 bytes) for the sighash.
        Example: signature = secp256k1.schnorr_sign(sighash, private_key).
    Construct Witness:
        For key-path spend: Witness stack contains only the 64-byte Schnorr signature.
        Example: [signature].

Step 6: (Optional) Script-Path Spend

If spending via a script path:

Select a Script:
        Choose a script from the Merkle tree committed in the output.
    Construct Control Block:
        Include the version (0x01 for Taproot), internal public key, and Merkle proof (path to the scriptâ€™s leaf).
        Example: control_block = <version> || <internal_pubkey> || <merkle_path>.
        Witness Stack:
        Stack: [script_input, script, control_block].
        script_input satisfies the selected script (e.g., signatures for a multisig).

Step 7: Serialize the Transaction

    Transaction Format:
        Version (4 bytes).
        Marker and flag ( 0x00 0x01 for SegWit).
        Input count (varint).
        Inputs (txid, vout, scriptSig, sequence).
        Output count (varint).
        Outputs (amount, scriptPubKey).
        Witness data (for each input).
        Locktime (4 bytes).
    Serialize:
        Convert all fields to hex.
        Example (simplified): 0200000001<txid><vout><scriptSig><sequence>01<amount><scriptPubKey>0001<signature>00000000.

Step 8: Validate and Broadcast

    Validate Locally:
        Verify the transaction format and signatures using a Bitcoin library or node.
        Check that inputs cover outputs plus fees.
    Broadcast:
        Submit the transaction to the Bitcoin network via a node (e.g., bitcoin-cli sendrawtransaction <hex>).
        Alternatively, use a library to broadcast (e.g., bitcoinlib.network.broadcast_transaction).

Opcodes from 0x50 to 0x60 and 0x62 to 0x6F are reserved as OP_SUCCESSx

* Imports
#+begin_src python :tangle yes :results silent :session pybtc
from hashes import tagged_hash
from helpers import bytes_to_hex, hex_to_bytes

#+end_src

* Functions
#+begin_src python :tangle yes :results silent :session pybtc
def tapleaf_hash(script: str = None, tapscript_ver: hex = '0xc0'):
    '''Hash a TapScript'''
    if not script:
        print("Wat? You forgot the tap script.")
        return None
    return tagged_hash("TapLeaf", hex_to_bytes(tapscript_ver + script))

def build_taptree(leafhashes: list) -> int:
    '''Build Merkle tree from list of scripts and return root'''
    if not scripts:
        raise ValueError("Script list cannot be empty")

    leaves = []

    while len(leaves) > 1:
        tmp_leaves = []
        for i in range(0, len(leaves), 2):
            if i+1 >= len(leaves):
                leaves.append(leaves[-1])
            left, right = sorted([leaves[i], leaves[i+1]])
            parent = tagged_hash("TapBranch", left + right)
            tmp_leaves.append(parent)
        leaves = tmp_leaves

    return leaves[0]

def compute_taproot_output(internal_pubkey, merkle_root):
    '''Compute the Taproot pubkey and scriptPubKey'''
    if len(internal_pubkey) != 32:
        raise ValueError("Internal pubkey must be 32 bytes")
    if len(merkle_root) != 32:
        raise ValueError("Merkle root must be 32 bytes")

    tweak = tagged_hash("TapTweak", internal_pubkey + merkle_root)

    tweaked_pubkey = tweak
    script_pubkey = b"\x51\x20" + tweaked_pubkey

    return tweaked_pubkey, script_pubkey

def create_taproot_mast(scripts, internal_pubkey_hex):
    '''Create a Taproot MAST from scripts and internal pubkey'''
    try:
        internal_pubkey = hex_to_bytes(internal_pubkey_hex)
        merkle_root= merkelize_scripts(scripts)
        tweaked_pubkey, script_pubkey = compute_taproot_output(internal_pubkey, merkle_root)
        return {
            "merkle_root": bytes_to_hex(merkle_root),
            "tweaked_pubkey": bytes_to_hex(tweaked_pubkey),
            "script_pubkey": bytes_to_hex(script_pubkey)
        }
    except Exception as e:
        raise ValueError(f"Error creating Taproot MAST: {str(e)}") from e

#+end_src
