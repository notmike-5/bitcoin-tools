'''test_disable_key_spend_path.py'''

import random

# simple, though non-cryptographic hash function
def djb2(s: str) -> int:
    hash = 5381
    for c in s:
        hash = ((hash << 5) + hash) + ord(c)  # hash * 33 + ord(c)
    return hash & 0xFFFFFFFF  # Return 32-bit hash

# consider a toy field like Z_7, and take it’s multiplicative group of units
# the binary operation is multiplication modulo 7

p = 7

G = [n+1 for n in range(p-1)]
O = {}

# get order of an element
def order(a):
    k = 1

    while a**k % p != 1:
        k += 1

    return k

# show multiplication table
def show_multiplication_table():
    print("\t", end='')
    for i in range(1, p):
        print(f"\t{i}\t", end='')
    print(f"\n{'----' * p}")

    for i in range(1, p):
        print(f"{i}\t|", end='')
        for j in range(1, p):
            print(f"\t{i*j % p}\t", end='')
        print("\n")

# generate subgroups
for i, a in enumerate(G):
    O[i] = [a**k % p for k in range(1, order(a)+1)]

# show subgroups
def show_subgroups():
    for i in range(p-1):
        print(f"{O[i]}\t subgroup generated by {i+1}")

# generators are elements a with order(a) == p-1
generators = [i+1 for i in range(0, p-1) if len(O[i]) == p-1]
g = random.choice(generators)

print(f"generator is {g}")
# okay, enough of that. Let us ’disable’ some privkey
k = random.choice(range(1,p))
forbidden_keypair = (k, pow(g, k, p))

print(f"forbidden keypair is (k, g**k % p) = {forbidden_keypair}")

# now let’s see if we can generate the pubkey other ways
for k in range(p):
    if g**k % p == forbidden_keypair[1]:
        print(f"(k={k}, g**k % p = {pow(g, k, p)})")
